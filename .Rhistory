shiny::runApp()
runApp()
runApp()
?eventReactive()
?reactive()?
a
?reactive
?reactive()
??reactive
?reactive
shiny::runApp()
?actionButton
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?outputOptions
runApp()
runApp()
runApp()
#Host and Prey Parameters
defPars_HX <- c(
#Host
j_HT0=0.03, #Host biomass turnover rate per day (1/d)
n_NH=0.18, #N:C (Nitrogen to Carbon) ratio in host biomass (no units)
sigma_NH=0.9, #Proportion of host nitrogen turnover recycled (no units)
sigma_CH=0/1, #Proportion of host carbon turnover recycled (no units)
j_Nm=0.035, #Maximum specific host DIN uptake rate (molN/CmolH/d)
j_HGm=1, #Maximum specific host growth rate (CmolH/CmolH/d)
k_CO2=10, #Rate of host CCM's (molCO2/molC/d)
K_N=1.5e-6, #Half-saturation constant for host DIN uptake (molN/L)
H_0=1, #Initial host biomass (CmolH)
#Prey
n_NX=0.2, #N:C ratio in prey biomass (no units)
j_Xm=0.13, #Maximum specific host feeding rate (molX/CmolH/d)
K_X=1e-6 #Half-saturation constant for host feeding (CmolX/L)
)
#Host and Prey Parameters
defPars_HX <- c(
#Host
j_HT0=0.03, #Host biomass turnover rate per day (1/d)
n_NH=0.18, #N:C (Nitrogen to Carbon) ratio in host biomass (no units)
sigma_NH=0.9, #Proportion of host nitrogen turnover recycled (no units)
sigma_CH=0/1, #Proportion of host carbon turnover recycled (no units)
j_Nm=0.035, #Maximum specific host DIN uptake rate (molN/CmolH/d)
j_HGm=1, #Maximum specific host growth rate (CmolH/CmolH/d)
k_CO2=10, #Rate of host CCM's (molCO2/molC/d)
K_N=1.5e-6, #Half-saturation constant for host DIN uptake (molN/L)
H_0=1, #Initial host biomass (CmolH)
#Prey
n_NX=0.2, #N:C ratio in prey biomass (no units)
j_Xm=0.13, #Maximum specific host feeding rate (molX/CmolH/d)
K_X=1e-6 #Half-saturation constant for host feeding (CmolX/L)
)
runApp()
runApp()
load("~/R/newCoralShiny/.RData")
?lapply
#Function coralStep takes an input state vector for the model and returns the
#next step along time
coralStep <- function(inState=c(time, L, N, X, j_X, j_N, r_NH, rho_N, j_eC,
j_CO2, j_HG, r_CH, dH.Hdt, H, r_NS, j_L,
j_CP, j_eL, r_NPQ, j_SG, rho_C, j_ST, r_CS,
c_ROS, dS.Sdt, S)){
outState
}
length(coralStep())
#Function coralStep takes an input state vector for the model and returns the
#next step along time
coralStep <- function(inState=c(time, L, N, X, j_X, j_N, r_NH, rho_N, j_eC,
j_CO2, j_HG, r_CH, dH.Hdt, H, r_NS, j_L,
j_CP, j_eL, r_NPQ, j_SG, rho_C, j_ST, r_CS,
c_ROS, dS.Sdt, S)){
outState<-inState
}
length(coralStep)
outSTate
outState
coralStep
coralStep()
length(coralStep)
length(coralStep())
#Function coralStep takes an input state vector for the model and returns the
#next step along time
coralStep <- function(inState=c(time=NA, L=NA, N=NA, X=NA, j_X=NA,j_N=NA, r_NH=NA,
rho_N=NA, j_eC=NA, j_CO2=NA, j_HG=NA, r_CH=NA,
dH.Hdt=NA, H=NA, r_NS=NA, j_L=NA, j_CP=NA, j_eL=NA,
j_NPQ=NA, j_SG=NA, rho_C=NA, j_ST=NA, r_CS=NA, c_ROS=NA,
dS.Sdt=NA, S=NA)){
outState<-inState
}
length(coralStep)
length(coralStep())
coralStep(1,1,1,1,1,1,1,1)
?rep
#Create time list
time <- 0:modelLength
modelLength=10
#Create time list
time <- 0:modelLength
time
#Create time list
time <- c(0:modelLength)
time
time[1]
time[10]
dt=0.1
#Create time list
time <- c(0:(modelLength/dt))
time
#Create time list
time <- c(0:(modelLength/dt),list())
list
list[1]
time
time[1]
#Create coral list
coral <- c(t=0:(modelLength/dt),list())
coral[1]$var<-list(1,2,3)
#Create coral list
coral <- c(t=0:(modelLength/dt),var=list())
coral[1]$var[1]<-1
coral
coral$t11
#Create coral list
coral <- list(t=0:(modelLength/dt),data=list())
coral$t
?lapply
#Initialize coral list
coral <- list(list(t=0,data=list()))
#Create variable lists for Host
for(var in lapply(c("j_X", "j_N", "r_NH", "rho_N", "j_eC", "j_CO2", "j_HG",
"r_CH", "dH.Hdt", "H"), "coral$data$")){
assign(var, rep(NA, times=modelLength))
}
#Create time list
time <- c(t=0:(modelLength/dt))
time$t
time[0]
time[1]
t3
time[4]
sliderInput?
d
shiny::runApp()
runApp()
runApp()
radioButtons()?
a
?radioButtons
runApp()
#Symbiont Parameters
defPars_S <- list(
y_C=0.8, #Yield of biomass formation from carbon (C-mol mol C^-1)
j_ST0=0.03, #Maintenance rate of symbiont biomass (C-mol S C-mol S^-1 d^-1)
n_NS=0.13, #N:C ratio in symbiont biomass (no units)
y_CL=0.1, #L:C (Light to Carbon) ratio in fixed carbon, i.e. quantum yield (molC/mol ph)
k_NPQ=112, #Capacity of non-photochemical quenching (mol photons/CmolS/d)
k_ROS=80, #Amount of excess light beyond NPQ capacity that doubles ROS (Reactive Oxygen Species) production relative to baseline (mol ph/CmolS/d)
k=1, #Exponent on ROS production (no units)
aStar=1.34, #Effective symbiont specific cross-sectional area for photosynthesis (m^2/C-molS)
sigma_NS=0.9, #Proportion of nitrogen turnover recycled in symbiont(no units)
sigma_CS=0.9, #Proportion of metabolic CO2 recycled to photosynthesis (no units)
j_CPm=2.8, #Maximum specific photosynthesis rate (Cmol/CmolS/d)
j_SGm=0.25, #Maximum specific symbiont growth rate (CmolS/CmolS/d)
S_0=1, #Initial symbiont biomass (CmolS)
b=5 #Scaling parameter for bleaching response
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
?pmax
}
#Function runCoral models the growth of symbiont and host biomasses over the
#given time interval, and returns a list of vectors that describe the
#state at a given time
runCoral <- function(time, dt, env, pars_HX, pars_S) {
#Create variable lists for Host
for(var in c("j_X", "j_N", "r_NH", "rho_N", "j_eC", "j_CO2", "j_HG",
"r_CH", "dH.Hdt", "H")){
assign(var, rep(NA, times=length(time)))
}
#Create variable lists for Symbiont
for (var in c("r_NS", "j_L", "j_CP", "j_eL", "j_NPQ", "j_SG", "rho_C",
"j_ST", "r_CS", "c_ROS", "dS.Sdt", "S")) {
assign(var, rep(NA, times=length(time)))
}
#Initial Host fluxes
j_X <- MMk(env$X, pars_HX$j_Xm, pars_HX$K_X) #Uptake of prey
j_N <- MMk(env$N, pars_HX$j_Nm, pars_HX$K_N) #Uptake of DIN
r_NH <- rep(x=(pars_HX$j_HT0 * pars_HX$n_NH * pars_HX$sigma_NH),
times=length(time)) #Recycled Nitrogen from host turnover
rho_N[1] <- j_N[1] #Nitrogen shared with the Symbiont
j_eC[1] <- pars_HX$j_eC0 #Excess carbon used to activate host CCMs
j_HG <- pars_HX$j_HG0 #Host biomass growth rate
r_CH[1] <- pars_HX$j_HT0 * pars_HX$sigma_CH #Recycled CO2 from host
dH.Hdt[1] <- pars_HX$jHGm #Total host growth rate
H[1] <- pars_HX$H_0 #Initial host biomass
#Initial Symbiont fluxes
r_NS <- pars_S$j_ST0 * pars_S$n_NS * pars_S$sigma_NS #Recycled Nitrogen from Symbiont turnover
j_L[1] <- env$L[1] * pars$aStar #Initial uptake of light
j_CP[1] <- alwaysPositive(synth(j_L[1] * pars_S$y_CL,
j_CO2[1]*H[1]/pars_S$S_0, pars_S$j_CPm)) #Initial production of biomass from photosynthesis
j_eL[1] <- alwaysPositive(rejflux=(j_L[1] - j_CP[1]/pars_S$y_CL)) #Excess light energy in the system
j_NPQ[1] <- pars_S$k_NPQ #Total capacity of nonphotochemical quenching
j_SG[1] <- pars_S$j_SGm/10 #Production of Symbiont biomass
rho_C[1] <- j_CP[1] #Fixed carbon shared with host
j_ST[1] <- pars_S$j_ST0 #Initial biomass turnover rate
r_CS[1] <- pars_S$j_ST0 * pars_S$sigma_CS #Recycled CO2 from symbiont
c_ROS[1] <- 1 #Reactive oxygen species production relative to baseline
dS.Sdt[1] <- pars_S$j_SGm #Total Symbiont growth rate
S[1] <- pars_S$S_0 #Initial Symbiont biomass
#Run Model
for (t in 2:length(time)) {
#S.t <- sum(S[t-1,])  For use when having more than one symbiont. For now, use:
S.t <- S[t-1] #Previous step symbiont biomass
j_L[t] <- (1.256307 + 1.385969 * exp(-6.479055 * (S.t/H[t-1]))) *
env$L[t] * pars_S$aStar #New uptake of light into symbiont
r_CS[t] <- pars_S$sigma_CS * (pars_S$j_ST0 +
(1-pars_S$y_C)*j_SG[t-1,]/pars_S$y_C) #New metabolic CO2 from biomass turnover
j_CP[t] <- synth(j_L[t] * pars_S$y_CL, (j_CO2[t-1] + r_CH[t-1])*
H[t-1]/S.t + rCS[t,], pars$jCPm) / cROS[t-1] #New photosynthesis rate
j_eL[t] <- alwaysPositive(rejFlux = j_L[t] - j_CP[t]/pars_S$y_CL) #Excess light energy in the system
j_NPQ[t] <- (pars_S$k_NPQ^(-1)+j_eL[t]^(-1))^(-1/1) #New capacity for nonphotochemical quenching
c_ROS[t] <- 1 + (alwaysPostive(rejFlux = j_eL[t] - j_NPQ[t]) /
pars_S$k_ROS)^pars_S$k #Creation of ROS relative to baseline levels
j_SG[t] <- synth(pars_S$y_C*j_CP[t], (rho_N[t-1]*H[t-1]/S.t + r_NS[t])/
pars_S$n_NS, pars_S$j_SGm) #Biomass production of Symbiont
rho_C[t] <- alwaysPositive(j_CP[t] - j_SG[t]/pars_S$y_C) #Symbiont produced carbon shared with Host
dS.Sdt[t] <- j_SG[t] - jST[t] #Total growth rate of symbiont
S[t] <- S[] + dS.Sdt[t] * S[t-1] * dt #Symbiont biomass at time t
#rhoC.t <- sum(rho_C[t,]*S[t-1,])  For use when having more than one symbiont. For now, use:
rhoC.t <- rho_C[t]*S[t-1] #Symbiont use of carbon
j_HG[t] <- synth(pars_S$y_C*(rho_C.t/H[t-1] + j_X[t]),
(j_N[t] + pars_HX$n_NX*j_X[t] + r_NH[t]) /
pars_HX$n_NH, pars_HX$j_HGm) #Host biomass production rate
rho_N[t] <- alwaysPositive(j_N[t] + pars_HX$n_NX * j_X[t] +
r_NH[t] - pars_HX$nNH * j_HG[t]) #Nitrogen shared with Symbiont
j_eC[t] <- alwaysPositive(j_X[t] + rho_C.t/H[t-1] - j_HG[t]/pars_S$y_C) #Excess carbon in the system
r_CH[t] <- pars_HX$sigma_CH * (pars$j_HT0 + (1-pars_S$y_C)*j_HG[t]/pars_S$yC) #Recycled CO2 from host
j_CO2[t] <- pars_HX$k_CO2 * j_eC[t] #CO2 sent from host CCMs to symbiont
dH.Hdt[t] <- j_HG[t] - pars_HX$jHT0 #Total host growth rate
H[t] <- H[t-1] + dH.Hdt[t] * H[t-1] * dt #Host biomass at time t
}
#Generate and Return output
}
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
?eventReactive
runApp()
runApp()
runApp()
dH.Hdt[1] <- pars_HX$j_HGm #Total host growth rate
runApp()
runApp()
runApp()
j_eL[1] <- alwaysPositive(rejFlux=j_L[1] - j_CP[1]/pars_S$y_CL) #Excess light energy in the system
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
j_HG[t] <- synth(pars_S$y_C*(rho_C.t/H[t-1] + j_X[t]),
(j_N[t] + pars_HX$n_NX*j_X[t] + r_NH[t]) /
pars_HX$n_NH, pars_HX$j_HGm) #Host biomass production rate
runApp()
runApp()
r_CH[t] <- pars_HX$sigma_CH * (pars$j_HT0 + (1-pars_S$y_C)*j_HG[t]/pars_S$yC) #Recycled CO2 from host
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?dataTableOutput()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
length(time)
runApp()
runApp()
runApp()
runApp()
?seq
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
c_ROS[1] <- 0 #Reactive oxygen species production relative to baseline
shiny::runApp()
if (is.na(substrateTwo)) {
return(2)
}
runApp()
runApp()
runApp()
#Function alwaysPositive returns 0 if the given rejection flux rejFlux is
#negative and rejflux if it is greater than zero because rejection fluxes
#must always be positive
alwaysPositive <- function(rejFlux) {
max(0,rejFlux, na.rm = T)
}
shiny::runApp()
install.packages("devtools")
shiny::runApp()
runApp()
j_SG[t] <- synth(pars_S$y_C*j_CP[t], (rho_N[t-1]*H[t-1]/S[t-1] + r_NS[t-1])/
pars_S$n_NS, pars_S$j_SGm) #Biomass production of Symbiont
rho_C[t] <- alwaysPositive(j_CP[t] - j_SG[t]/pars_S$y_C) #Symbiont produced carbon shared with Host
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?pmax
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?rep
runApp()
runApp()
runApp()
test <- rep(x = 1, times = 10)
test[0]
test[1]
test[2]
test[3]
test[[1]]
test[[2]]
test[[[3]]]
test[[0]]
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
